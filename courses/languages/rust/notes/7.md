# Note Of Work

## Concept of Ownership in Rust

From my current understanding of the 4th chapter, Rust's Ownership system, is a way of managing data (variable) in a given scope of function call;

There are 3 rule to be aware aware of:

- A variable as one Owner, and it's memeory is automaticaly freed, when it's value goes out of scope 
(no one own is it in current scope)

- A variable's value can be borrowed, as the owner is only one who can morph or read the value it possess,
so to morph of read it one need to either `move` or `borrow a reference to it` the value

- A given value can have, anynumber of `reference` (read only) but only one `mutable reference` at a time

### Scoping

considering:

```rs
fn main (){
  let x = 0; 
    {
        let y = 0;
        // scope of y end here
    } 
    // scope of x end here
}
```

the things observerd in this piece of code is as any common language:
x at top level scope exit in y is sub level scope,

Difference being there life time, In there Rust there is no such thing as garbage collection.
At Each end of a given scope, Rust calls an fn for memory liberation (drop()). any value whom owner goes out of scope it discarded.

### Moving Data

In rust, since the data is owned, passing it is equialvent to copying it (if possible) or `moving` it

```rs
let x = String::from("test");
let y = x
prinln!("{x} {y}"); // x no longuer exit
```

In common language this is not a problem, in rust it is, as `y = x` is not assigning a copy, but `moving the right of owner of x to y`

## Borrowing Data

In order to read/edit data without having to `move` it, we have for option the `borrowing` mechanic

```rs
let x = String::from("test");
let y = &x
prinln!("{x} {y}");
```

Then `x` like `y` both exist, as `y` does not to have ownership over the data, but a reference to it

## Heap & Stack, When to Move, Borrow or Copy

The Main difference in a borrowable, movable, copyable var, is where they live in memory.

When executing rust code, we have to deal with two kind of memory to store variable in the current scope

Heap and Stack memory.

### What is the stack

The stack is a fixed amount of memory allocated at start of the program or function,
this amount cannot grow once set, only once freed a new amount can be added.

to illustrate this consider:

```rs
fn main(){
    ...main_scope;
    some_fn()
}

fn some_fn(){
    ...fn_scope;
    some_deep_fn();
}
```

when main comes in scope it's pushed on the stack:

|main_scope|

when reaching some fn it's also pushed on the stack:

|some_fn_scope|
|main_scope   |

and last some_deep_fn

|some_deep_fn |
|some_fn_scope|
|main_scope   |

#### How Does the stak works

**Definition**:  The stack is a continious section of memory that store function scope (call stack), it can only contain element of fixed size (bite length)

**Analogy**: once allocated on the stack, an fn's memory cannot grow so everything that goes on the stack must the staticaly of known size.

and that's where rust is typing come in handy, in rust, the typing isn't for IDE inference but for the rust compiler itself:

if in typescript this:
    let x: number = 12;

means: have x be considered a number by the ide

in rust:
    let x: u8 = 10;

means: have the compiler allocate an unsigned integer of length height bit or one octect if you prefer

#### But why do we need to move and borrow ?

The stack is like a pile of plates: you could try to reach a plate lower down, but you’d need to know exactly where it is — and even then, you can’t be sure someone else hasn’t taken it.

> **Physically**: The CPU can access any memory address on the stack. **Officially**: Only the current frame (the top of the stack) is considered valid and readable as the rest is locked by many language, including rust.

Imagine if helper_fn() could randomly read main()’s memory:

- **Security risk**: Functions could steal passwords or sensitive data from other functions.
- **Safety risk**: main() might have already freed or moved that memory, and helper_fn() wouldn’t know.

To avoid these issues — which are the root of ~80% of C-related memory bugs — Rust requires you to move the values you need or borrow them into the current scope.

Again remember that moving is different from borrowing, as moving, is like "cuting a file" where borrowing is like a "symbolic link".
So when "some_fn" finish executing, anything that as been moved in it's scope would be removed along with it, where anything borrowed would unaffected as it never "moved"

#### When to copy

copying data is automatically handled by rust as it's ridiculously cheap, for as long the data implement the trait copy (a behavior or a method would the equivalent in other programming lang)

### What is the heap

**Definition**: the heap is a non continous set of memory, whom can grow on demand

**Analogy**: where the stack, needs data of fixed size only, we sometime need to handle data of unknow shape, eg user input. one user might have a 10 letter password, another 22. to handle that we use the Heap.

On demand, the memory allocator find a free plage of memory on the heap, and return a pointer towards it (this pointer is stored on stack as it's of known size);

so the diff:

```rs
let x = "static value";
let y = String::from("dynamic string");
```

is that `y` can grow, eg `y.push_str(...)`, where x is lenght as be known string, and cannot grow in time, hence why in rust exist the type "str" and "String" whom both represent a string, but one being a static string the other a growable reducable string.

### Note on stack and heap

reading the stack is ridulously fast, as the cpu jump in matter of extremly close position to read the data it needs, as remenber the stack is continious [v1, v2, v3]

reading from the heap is less that fast as the cpu jump around in memory:

```plaintext
[v3]    [v5]
    [v1][v4]
[v6]    [v2]
```
