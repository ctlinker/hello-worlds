# Note of Work

Note: From my understanding of the chapter 7 of the rust programming book  
Warning: The content might be vocabulary inaccurate, It’s a metaphorical description

Rust file dependency resolution model differs slightly from the norm. In order to achieve the famous “import” \\ “export”, rust break down the concept of “bringing into scope” and “exposing the said scope” in the concept of **module tree** and **three keywords** :

- **mod** : declare that **a module** exist and only that  
- **pub** : mark a function of \`sub-module\` as public (importable, exported)  
- **use** : bring into scope the \`public\` fn or sub-module scope you want

## What is a module really

***Technically*** a module is **any .rs** (except the [main.rs](http://main.rs)) in your project, or a directory which acts as a module. For example, let’s say that we decide to implement a simple guessing game, a binary search at human level :

```tree
├── Cargo.lock  
├── Cargo.toml  
└── src  
      ├── main.rs  
      ├── *logics.rs*  
      ├── logics  
       │   └──states.rs  
       │   └── difficulty.rs  
      ├── *utils.rs*  
      └── utils  
         └── line.rs
```

In here, What is a module ? Every **.rs** file (except the main.rs) and directory. Let's take for example the “[line.rs](http://line.rs)” file to learn how to use the pub keyword.

## Case of Files

| // line.rs pub read\_ln\_as\<A: FromStr\>() \-\> Option\<A\> { ... } |
| :---- |

This mark, the `read_as_ln` function as public in the module “**line**” (yes a module’s name is just the file or dirname), as a module is just a file, a directory or a namespace inside a module eg :

| // line.rs mod my\_namespace {    pub read\_ln\_as\<A: FromStr\>() \-\> Option\<A\> { ... }} |
| :---- |

This create a **submodule** *`my_namespace`* inside the *`line`* module, then mark the
nested `read_as_ln` function inside it as public

note that **my\_namespace** is currently only visible by the [line.rs](http://line.rs) file, as we did not publish it eg : **pub mod** my\_namespace { ... }

Note: Yes module can be deeply nested eg:

| mod my\_namespace { pub mod other\_stuff {...} } |
| :---- |

## Case of Directories

In the case of directory, we are use a file with the same name, as our directory eg

  ├── `utils.rs`  
      └── `utils`  
         └── line[.rs](http://mod.rs)

A directory can expose its submodule (the file it contains), or again a namespace eg :

| *// utils.rs*pub mod line;pub mod hello { pub fn world(){ println\!("Hello worlds"); }} |
| :---- |

## Module Tree

The concept of module tree, states that a given module (dir or .rs file) can only see its direct neighbour or direct submodule. For example let’s `use` the line module in the utils module to bring into scope the read\_ln\_as fn :

| *// main.rs*mod utils;use utils::line::{read\_fn\_as};fn main { if let Some(difficulty) \= read\_ln\_as::\<u8\> {  ...      }} |
| :---- |

mod keyword declares that the utils module exists (in [main.rs](http://main.rs) or is a neighbouring file of [main.rs](http://main.rs)) and only that. The use keyword bring the public api of the utils mod into scope.

The module tree is an ownership at file level, so we can't reach the submodule of module with passing by the module in question and having the said module publish the said sub module.

## Extra

When dealing with nested namespace we want to use absolute path starting by `crate` eg :

| mod nspace { use crate::utils::line{...};  pub fn that\_use\_the\_utils() {    }} |
| :---- |

relative path exist through the `super` keyword which is the equivalent to “..*/*”. eg let’s say we have a nested file “random*/*gen\_guess” in the logic dir, and need something from the difficulty module it contains:

| use super::difficulty::{eval\_num\_of\_move\_required\_for}; |
| :---- |

here the super keyword doesn’t need us to declare the module, it’s just reaching for the parent of a given submodule

## End Note

Thanks stranger for taking time to read this lil piece of work. hope it was helpful
